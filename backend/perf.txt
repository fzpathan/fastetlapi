I'll create a comprehensive artifact with the formula validator that you can use in your project.
"""
Formula Validator - Secure AST-based validation for dynamic formula evaluation

This module provides secure validation and execution of dynamic formulas using
Python's Abstract Syntax Tree (AST) parsing. It prevents dangerous operations
while allowing safe mathematical and data manipulation expressions.

Author: Claude
Date: 2026-02-02
"""

import ast
from typing import Dict, List, Any, Optional


class FormulaValidator(ast.NodeVisitor):
    """
    Validates formula AST and extracts detailed node information.
    
    This class walks through the Abstract Syntax Tree of a formula string,
    validates each operation against whitelisted names and attributes, and
    collects detailed information about all nodes in the tree.
    """
    
    # Whitelist of allowed variable/function names
    ALLOWED_NAMES = {
        'sub_data_df', 'datetime', 'np', 'pd', 'abs', 'min', 'max', 
        'str', 'int', 'float', 'len', 'round', 'sum', 'any', 'all'
    }
    
    # Whitelist of allowed attributes (methods/properties)
    ALLOWED_ATTRIBUTES = {
        'timedelta', 'strftime', 'strptime', 'apply', 'dt', 'columns', 
        'values', 'isnull', 'fillna', 'dropna', 'days', 'seconds', 
        'date', 'time', 'year', 'month', 'day', 'hour', 'minute',
        'isna', 'notna', 'astype', 'replace', 'lower', 'upper', 'strip'
    }
    
    def __init__(self, formula_string: str, verbose: bool = True):
        """
        Initialize the validator.
        
        Args:
            formula_string: The formula string to validate
            verbose: Whether to print validation progress
        """
        self.formula_string = formula_string
        self.verbose = verbose
        self.nodes_info: List[Dict[str, Any]] = []
        self.errors: List[str] = []
    
    def visit_Name(self, node: ast.Name) -> None:
        """Validate and extract variable names."""
        value = node.id
        is_allowed = value in self.ALLOWED_NAMES
        
        self.nodes_info.append({
            'type': 'Variable',
            'value': value,
            'allowed': is_allowed,
            'line': node.lineno,
            'col': node.col_offset
        })
        
        if not is_allowed:
            error_msg = f"Variable '{value}' not allowed (line {node.lineno}, col {node.col_offset})"
            self.errors.append(error_msg)
            if self.verbose:
                print(f"❌ {error_msg}")
                print(f"   Allowed variables: {self.ALLOWED_NAMES}")
        else:
            if self.verbose:
                print(f"✓ Variable: '{value}'")
        
        self.generic_visit(node)
    
    def visit_Attribute(self, node: ast.Attribute) -> None:
        """Validate and extract attributes."""
        value = node.attr
        is_allowed = value in self.ALLOWED_ATTRIBUTES
        
        self.nodes_info.append({
            'type': 'Attribute',
            'value': value,
            'allowed': is_allowed,
            'line': node.lineno,
            'col': node.col_offset
        })
        
        if not is_allowed:
            error_msg = f"Attribute '.{value}' not allowed (line {node.lineno}, col {node.col_offset})"
            self.errors.append(error_msg)
            if self.verbose:
                print(f"❌ {error_msg}")
                print(f"   Allowed attributes: {self.ALLOWED_ATTRIBUTES}")
        else:
            if self.verbose:
                print(f"✓ Attribute: '.{value}'")
        
        self.generic_visit(node)
    
    def visit_Constant(self, node: ast.Constant) -> None:
        """Extract constant values."""
        self.nodes_info.append({
            'type': 'Constant',
            'value': node.value,
            'value_type': type(node.value).__name__,
            'allowed': True,
            'line': node.lineno,
            'col': node.col_offset
        })
        
        if self.verbose:
            print(f"✓ Constant: {node.value} ({type(node.value).__name__})")
        
        self.generic_visit(node)
    
    def visit_Call(self, node: ast.Call) -> None:
        """Validate and extract function calls."""
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
            is_allowed = func_name in self.ALLOWED_NAMES
            
            self.nodes_info.append({
                'type': 'Function Call',
                'value': func_name,
                'allowed': is_allowed,
                'line': node.lineno,
                'col': node.col_offset
            })
            
            if not is_allowed:
                error_msg = f"Function '{func_name}()' not allowed (line {node.lineno}, col {node.col_offset})"
                self.errors.append(error_msg)
                if self.verbose:
                    print(f"❌ {error_msg}")
            else:
                if self.verbose:
                    print(f"✓ Function: '{func_name}()'")
        
        elif isinstance(node.func, ast.Attribute):
            # Method calls are already validated by visit_Attribute
            if self.verbose:
                print(f"✓ Method call: .{node.func.attr}()")
        
        self.generic_visit(node)
    
    def visit_Subscript(self, node: ast.Subscript) -> None:
        """Extract subscript values (e.g., df['column'])."""
        # Handle different Python versions
        if isinstance(node.slice, ast.Constant):
            subscript_val = node.slice.value
        elif hasattr(ast, 'Index') and isinstance(node.slice, ast.Index):  # Python < 3.9
            if isinstance(node.slice.value, ast.Str):
                subscript_val = node.slice.value.s
            elif isinstance(node.slice.value, ast.Constant):
                subscript_val = node.slice.value.value
            else:
                subscript_val = "complex"
        else:
            subscript_val = "complex"
        
        self.nodes_info.append({
            'type': 'Subscript',
            'value': subscript_val,
            'allowed': True,
            'line': node.lineno,
            'col': node.col_offset
        })
        
        if self.verbose:
            print(f"✓ Subscript: [{subscript_val}]")
        
        self.generic_visit(node)
    
    def visit_Import(self, node: ast.Import) -> None:
        """Block import statements."""
        error_msg = f"Import statements not allowed (line {node.lineno})"
        self.errors.append(error_msg)
        if self.verbose:
            print(f"❌ {error_msg}")
    
    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        """Block import statements."""
        error_msg = f"Import statements not allowed (line {node.lineno})"
        self.errors.append(error_msg)
        if self.verbose:
            print(f"❌ {error_msg}")
    
    def is_valid(self) -> bool:
        """Check if validation passed."""
        return len(self.errors) == 0
    
    def get_summary(self) -> None:
        """Print summary of all nodes found."""
        print(f"\n{'='*70}")
        print(f"Formula Analysis Summary")
        print(f"{'='*70}")
        print(f"Formula: {self.formula_string}")
        print(f"\n{'Type':<20} {'Value':<30} {'Allowed':<10} {'Position'}")
        print(f"{'-'*70}")
        
        for info in self.nodes_info:
            pos = f"L{info['line']}:C{info['col']}"
            allowed = '✓' if info['allowed'] else '❌'
            value_str = str(info['value'])
            if len(value_str) > 28:
                value_str = value_str[:25] + "..."
            print(f"{info['type']:<20} {value_str:<30} {allowed:<10} {pos}")
        
        print(f"{'='*70}")
        
        if self.errors:
            print(f"\n❌ VALIDATION FAILED with {len(self.errors)} error(s):")
            for error in self.errors:
                print(f"   - {error}")
        else:
            print(f"\n✅ VALIDATION PASSED - All operations are allowed")
        
        print(f"{'='*70}\n")
    
    def get_node_info(self) -> List[Dict[str, Any]]:
        """Get list of all node information."""
        return self.nodes_info


def validate_and_eval(formula_string: str, 
                     context: Dict[str, Any], 
                     verbose: bool = True,
                     show_summary: bool = True) -> Any:
    """
    Validate and evaluate formula with detailed reporting.
    
    Args:
        formula_string: The formula to validate and execute
        context: Dictionary of variables available to the formula
        verbose: Whether to print validation progress
        show_summary: Whether to print a summary after validation
    
    Returns:
        The result of evaluating the formula
    
    Raises:
        ValueError: If formula validation fails or syntax error
        
    Example:
        >>> import datetime
        >>> import pandas as pd
        >>> df = pd.DataFrame({'date': ['2024-01-01']})
        >>> context = {'sub_data_df': df, 'datetime': datetime, 'pd': pd}
        >>> result = validate_and_eval("sub_data_df['date']", context)
    """
    if verbose:
        print(f"\n{'='*70}")
        print(f"Validating Formula")
        print(f"{'='*70}")
        print(f"Formula: {formula_string}\n")
    
    try:
        # Parse the formula
        tree = ast.parse(formula_string, mode='eval')
        
        # Validate and extract info
        validator = FormulaValidator(formula_string, verbose=verbose)
        validator.visit(tree)
        
        # Show summary if requested
        if show_summary:
            validator.get_summary()
        
        # If validation failed, raise error
        if not validator.is_valid():
            raise ValueError(f"Formula validation failed with {len(validator.errors)} error(s)")
        
        # If validation passed, evaluate
        result = eval(formula_string, {}, context)
        
        if verbose:
            print(f"✅ Formula executed successfully\n")
        
        return result
    
    except SyntaxError as e:
        error_msg = f"Syntax error in formula: {e}"
        if verbose:
            print(f"❌ SYNTAX ERROR: {e}")
            print(f"{'='*70}\n")
        raise ValueError(error_msg)
    
    except Exception as e:
        if verbose:
            print(f"❌ EXECUTION ERROR: {e}")
            print(f"{'='*70}\n")
        raise


def validate_formula_quiet(formula_string: str) -> Dict[str, Any]:
    """
    Validate formula and return results without printing.
    
    Args:
        formula_string: The formula to validate
    
    Returns:
        Dictionary with keys:
            - is_valid: bool, whether validation passed
            - errors: list of error messages
            - nodes: list of node information dictionaries
            
    Example:
        >>> result = validate_formula_quiet("sub_data_df['col'] + 1")
        >>> if result['is_valid']:
        >>>     print("Formula is valid!")
        >>> else:
        >>>     print(f"Errors: {result['errors']}")
    """
    try:
        tree = ast.parse(formula_string, mode='eval')
        validator = FormulaValidator(formula_string, verbose=False)
        validator.visit(tree)
        
        return {
            'is_valid': validator.is_valid(),
            'errors': validator.errors,
            'nodes': validator.nodes_info
        }
    except SyntaxError as e:
        return {
            'is_valid': False,
            'errors': [f"Syntax error: {e}"],
            'nodes': []
        }


# Example usage
if __name__ == "__main__":
    import datetime
    import pandas as pd
    import numpy as np
    
    # Create sample data
    sub_data_df = pd.DataFrame({
        'Temp1': pd.to_datetime(['2024-01-01', '2024-01-02', '2024-01-03']),
        'Value': [100, 200, 300]
    })
    
    # Define context
    context = {
        'sub_data_df': sub_data_df,
        'datetime': datetime,
        'np': np,
        'pd': pd,
        'abs': abs
    }
    
    # Example 1: Valid formula
    print("Example 1: Valid Formula")
    formula1 = "(sub_data_df['Temp1'] - datetime.timedelta(days=1)).dt.strftime('%Y-%m-%d')"
    try:
        result1 = validate_and_eval(formula1, context)
        print(f"Result: {result1}\n")
    except ValueError as e:
        print(f"Error: {e}\n")
    
    # Example 2: Invalid formula (dangerous function)
    print("\nExample 2: Invalid Formula (dangerous function)")
    formula2 = "eval('malicious code')"
    try:
        result2 = validate_and_eval(formula2, context)
    except ValueError as e:
        print(f"Caught error as expected: {e}\n")
    
    # Example 3: Quiet validation
    print("\nExample 3: Quiet Validation")
    formula3 = "sub_data_df['Value'] * 2"
    result3 = validate_formula_quiet(formula3)
    print(f"Validation result: {result3}")
This artifact provides a complete, production-ready formula validation system that you can integrate into your project. It includes detailed documentation, examples, and handles edge cases across different Python versions.
