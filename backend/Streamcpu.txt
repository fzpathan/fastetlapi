import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import re
import os

# Page configuration
st.set_page_config(
    page_title="System Monitoring Dashboard",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
    <style>
    .metric-card {
        background-color: #f0f2f6;
        padding: 20px;
        border-radius: 10px;
        margin: 10px 0;
    }
    </style>
""", unsafe_allow_html=True)

def parse_memory_value(mem_str):
    """Parse memory string like '8.50GB' to bytes"""
    if not mem_str or pd.isna(mem_str):
        return None
    
    units = {'B': 1, 'KB': 1024, 'MB': 1024**2, 'GB': 1024**3, 'TB': 1024**4}
    
    match = re.match(r'([\d.]+)([A-Z]+)', mem_str.strip())
    if match:
        value, unit = match.groups()
        return float(value) * units.get(unit, 1)
    return None

def bytes_to_gb(bytes_value):
    """Convert bytes to GB"""
    if bytes_value is None:
        return None
    return bytes_value / (1024**3)

def parse_log_file(log_file):
    """Parse the CPU usage log file"""
    data = []
    
    if not os.path.exists(log_file):
        return pd.DataFrame()
    
    with open(log_file, 'r') as f:
        for line in f:
            # Skip header lines and empty lines
            if line.startswith('=') or line.strip() == '' or 'Monitoring Started' in line:
                continue
            
            # Parse log entry
            try:
                parts = line.strip().split(' | ')
                if len(parts) < 3:
                    continue
                
                timestamp_str = parts[0].strip()
                timestamp = pd.to_datetime(timestamp_str)
                
                # Extract CPU percentage
                cpu_match = re.search(r'CPU:\s+([\d.]+)%', line)
                cpu_percent = float(cpu_match.group(1)) if cpu_match else None
                
                # Extract frequency
                freq_match = re.search(r'Freq:\s+([\d.]+)MHz', line)
                freq = float(freq_match.group(1)) if freq_match else None
                
                # Extract load averages
                load_match = re.search(r'Load:\s+([\d.]+)/([\d.]+)/([\d.]+)', line)
                load_1min = float(load_match.group(1)) if load_match else None
                load_5min = float(load_match.group(2)) if load_match else None
                load_15min = float(load_match.group(3)) if load_match else None
                
                # Extract memory metrics
                mem_percent_match = re.search(r'MEM:\s+([\d.]+)%', line)
                mem_percent = float(mem_percent_match.group(1)) if mem_percent_match else None
                
                mem_used_match = re.search(r'Used:\s+([\d.]+[A-Z]+)', line)
                mem_used = parse_memory_value(mem_used_match.group(1)) if mem_used_match else None
                
                mem_avail_match = re.search(r'Avail:\s+([\d.]+[A-Z]+)', line)
                mem_available = parse_memory_value(mem_avail_match.group(1)) if mem_avail_match else None
                
                mem_total_match = re.search(r'Total:\s+([\d.]+[A-Z]+)', line)
                mem_total = parse_memory_value(mem_total_match.group(1)) if mem_total_match else None
                
                swap_match = re.search(r'SWAP:\s+([\d.]+)%', line)
                swap_percent = float(swap_match.group(1)) if swap_match else None
                
                # Extract per-core usage
                core_match = re.search(r'Per-Core:\s+\[(.*?)\]', line)
                core_usage = []
                if core_match:
                    core_str = core_match.group(1)
                    core_usage = [float(x.strip('%')) for x in core_str.split(',')]
                
                data.append({
                    'timestamp': timestamp,
                    'cpu_percent': cpu_percent,
                    'frequency': freq,
                    'load_1min': load_1min,
                    'load_5min': load_5min,
                    'load_15min': load_15min,
                    'mem_percent': mem_percent,
                    'mem_used': mem_used,
                    'mem_available': mem_available,
                    'mem_total': mem_total,
                    'swap_percent': swap_percent,
                    'core_usage': core_usage
                })
            except Exception as e:
                continue
    
    return pd.DataFrame(data)

def main():
    st.title("ðŸ“Š System Monitoring Dashboard")
    st.markdown("Real-time CPU & Memory utilization analysis")
    
    # Sidebar
    st.sidebar.header("âš™ï¸ Configuration")
    
    log_file = st.sidebar.text_input("Log File Path", value="cpu_usage.log")
    
    # Auto-refresh option
    auto_refresh = st.sidebar.checkbox("Auto-refresh (every 30s)", value=True)
    if auto_refresh:
        st.sidebar.info("Dashboard will refresh automatically")
        # Auto refresh every 30 seconds
        st.rerun()
    
    # Time range filter
    st.sidebar.subheader("Time Range")
    time_range = st.sidebar.selectbox(
        "Select Range",
        ["Last 1 Hour", "Last 6 Hours", "Last 12 Hours", "Last 24 Hours", "All Data"]
    )
    
    # Load data
    df = parse_log_file(log_file)
    
    if df.empty:
        st.error(f"âŒ No data found in '{log_file}'. Make sure the monitoring script is running!")
        st.info("ðŸ’¡ Start the monitoring script first: `python cpu_monitor.py`")
        return
    
    # Filter by time range
    now = datetime.now()
    if time_range == "Last 1 Hour":
        df = df[df['timestamp'] >= now - timedelta(hours=1)]
    elif time_range == "Last 6 Hours":
        df = df[df['timestamp'] >= now - timedelta(hours=6)]
    elif time_range == "Last 12 Hours":
        df = df[df['timestamp'] >= now - timedelta(hours=12)]
    elif time_range == "Last 24 Hours":
        df = df[df['timestamp'] >= now - timedelta(hours=24)]
    
    # Summary metrics
    st.header("ðŸ“ˆ Current Statistics")
    col1, col2, col3, col4, col5, col6 = st.columns(6)
    
    if not df.empty:
        latest = df.iloc[-1]
        
        with col1:
            st.metric(
                "Current CPU Usage",
                f"{latest['cpu_percent']:.1f}%",
                delta=f"{latest['cpu_percent'] - df.iloc[-2]['cpu_percent']:.1f}%" if len(df) > 1 else None
            )
        
        with col2:
            st.metric(
                "Average CPU",
                f"{df['cpu_percent'].mean():.1f}%"
            )
        
        with col3:
            st.metric(
                "Peak CPU",
                f"{df['cpu_percent'].max():.1f}%"
            )
        
        with col4:
            if latest['mem_percent']:
                st.metric(
                    "Memory Usage",
                    f"{latest['mem_percent']:.1f}%",
                    delta=f"{latest['mem_percent'] - df.iloc[-2]['mem_percent']:.1f}%" if len(df) > 1 else None
                )
        
        with col5:
            if latest['mem_used']:
                st.metric(
                    "Memory Used",
                    f"{bytes_to_gb(latest['mem_used']):.2f} GB"
                )
        
        with col6:
            if latest['mem_available']:
                st.metric(
                    "Memory Available",
                    f"{bytes_to_gb(latest['mem_available']):.2f} GB"
                )
    
    # CPU and Memory Usage Charts
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ðŸ’» CPU Usage Over Time")
        fig_cpu = go.Figure()
        fig_cpu.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['cpu_percent'],
            mode='lines',
            name='CPU Usage',
            line=dict(color='#1f77b4', width=2),
            fill='tozeroy',
            fillcolor='rgba(31, 119, 180, 0.2)'
        ))
        
        fig_cpu.update_layout(
            xaxis_title="Time",
            yaxis_title="CPU Usage (%)",
            hovermode='x unified',
            height=350,
            yaxis=dict(range=[0, 100])
        )
        
        st.plotly_chart(fig_cpu, use_container_width=True)
    
    with col2:
        st.subheader("ðŸ§  Memory Usage Over Time")
        fig_mem = go.Figure()
        fig_mem.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['mem_percent'],
            mode='lines',
            name='Memory Usage',
            line=dict(color='#ff7f0e', width=2),
            fill='tozeroy',
            fillcolor='rgba(255, 127, 14, 0.2)'
        ))
        
        fig_mem.update_layout(
            xaxis_title="Time",
            yaxis_title="Memory Usage (%)",
            hovermode='x unified',
            height=350,
            yaxis=dict(range=[0, 100])
        )
        
        st.plotly_chart(fig_mem, use_container_width=True)
    
    # Memory Details Chart
    st.subheader("ðŸ’¾ Memory Details (GB)")
    
    if df['mem_used'].notna().any():
        fig_mem_detail = go.Figure()
        
        fig_mem_detail.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['mem_used'].apply(bytes_to_gb),
            mode='lines',
            name='Used Memory',
            line=dict(color='#d62728', width=2),
            stackgroup='one'
        ))
        
        fig_mem_detail.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['mem_available'].apply(bytes_to_gb),
            mode='lines',
            name='Available Memory',
            line=dict(color='#2ca02c', width=2),
            stackgroup='one'
        ))
        
        fig_mem_detail.update_layout(
            xaxis_title="Time",
            yaxis_title="Memory (GB)",
            hovermode='x unified',
            height=350
        )
        
        st.plotly_chart(fig_mem_detail, use_container_width=True)
    
    # Additional Charts Row
    col1, col2 = st.columns(2)
    
    with col1:
        # CPU Frequency chart
        if df['frequency'].notna().any():
            st.subheader("ðŸ”„ CPU Frequency")
            fig_freq = go.Figure()
            fig_freq.add_trace(go.Scatter(
                x=df['timestamp'],
                y=df['frequency'],
                mode='lines',
                name='Frequency',
                line=dict(color='#9467bd', width=2)
            ))
            fig_freq.update_layout(
                xaxis_title="Time",
                yaxis_title="Frequency (MHz)",
                hovermode='x unified',
                height=300
            )
            st.plotly_chart(fig_freq, use_container_width=True)
    
    with col2:
        # Load average chart
        if df['load_1min'].notna().any():
            st.subheader("âš–ï¸ Load Average")
            fig_load = go.Figure()
            fig_load.add_trace(go.Scatter(
                x=df['timestamp'],
                y=df['load_1min'],
                mode='lines',
                name='1 min',
                line=dict(color='#2ca02c')
            ))
            fig_load.add_trace(go.Scatter(
                x=df['timestamp'],
                y=df['load_5min'],
                mode='lines',
                name='5 min',
                line=dict(color='#d62728')
            ))
            fig_load.add_trace(go.Scatter(
                x=df['timestamp'],
                y=df['load_15min'],
                mode='lines',
                name='15 min',
                line=dict(color='#9467bd')
            ))
            fig_load.update_layout(
                xaxis_title="Time",
                yaxis_title="Load",
                hovermode='x unified',
                height=300
            )
            st.plotly_chart(fig_load, use_container_width=True)
    
    # Swap Usage
    if df['swap_percent'].notna().any() and df['swap_percent'].max() > 0:
        st.subheader("ðŸ”„ Swap Memory Usage")
        fig_swap = go.Figure()
        fig_swap.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['swap_percent'],
            mode='lines',
            name='Swap Usage',
            line=dict(color='#e377c2', width=2),
            fill='tozeroy',
            fillcolor='rgba(227, 119, 194, 0.2)'
        ))
        fig_swap.update_layout(
            xaxis_title="Time",
            yaxis_title="Swap Usage (%)",
            hovermode='x unified',
            height=300,
            yaxis=dict(range=[0, 100])
        )
        st.plotly_chart(fig_swap, use_container_width=True)
    
    # Per-core usage heatmap
    st.header("ðŸ”¥ Per-Core CPU Usage")
    
    if df['core_usage'].notna().any() and len(df['core_usage'].iloc[-1]) > 0:
        # Create matrix for heatmap
        core_data = []
        timestamps = []
        for idx, row in df.iterrows():
            if row['core_usage']:
                core_data.append(row['core_usage'])
                timestamps.append(row['timestamp'])
        
        if core_data:
            core_matrix = pd.DataFrame(core_data, index=timestamps)
            
            fig_heatmap = go.Figure(data=go.Heatmap(
                z=core_matrix.T.values,
                x=core_matrix.index,
                y=[f"Core {i}" for i in range(len(core_matrix.columns))],
                colorscale='RdYlGn_r',
                zmid=50,
                zmin=0,
                zmax=100,
                colorbar=dict(title="CPU %")
            ))
            
            fig_heatmap.update_layout(
                xaxis_title="Time",
                yaxis_title="CPU Core",
                height=300
            )
            st.plotly_chart(fig_heatmap, use_container_width=True)
    
    # Statistics table
    st.header("ðŸ“Š Detailed Statistics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("CPU Statistics")
        cpu_stats_df = pd.DataFrame({
            'Metric': ['Average CPU', 'Minimum CPU', 'Maximum CPU', 'Std Deviation'],
            'Value': [
                f"{df['cpu_percent'].mean():.2f}%",
                f"{df['cpu_percent'].min():.2f}%",
                f"{df['cpu_percent'].max():.2f}%",
                f"{df['cpu_percent'].std():.2f}%"
            ]
        })
        st.dataframe(cpu_stats_df, use_container_width=True, hide_index=True)
    
    with col2:
        st.subheader("Memory Statistics")
        mem_stats_df = pd.DataFrame({
            'Metric': ['Average Memory', 'Minimum Memory', 'Maximum Memory', 'Std Deviation'],
            'Value': [
                f"{df['mem_percent'].mean():.2f}%",
                f"{df['mem_percent'].min():.2f}%",
                f"{df['mem_percent'].max():.2f}%",
                f"{df['mem_percent'].std():.2f}%"
            ]
        })
        st.dataframe(mem_stats_df, use_container_width=True, hide_index=True)
    
    # Raw data
    with st.expander("ðŸ“‹ View Raw Data"):
        display_df = df.copy()
        if 'mem_used' in display_df.columns:
            display_df['mem_used_gb'] = display_df['mem_used'].apply(bytes_to_gb)
            display_df['mem_available_gb'] = display_df['mem_available'].apply(bytes_to_gb)
            display_df['mem_total_gb'] = display_df['mem_total'].apply(bytes_to_gb)
        st.dataframe(display_df.tail(100), use_container_width=True)
    
    # Footer
    st.markdown("---")
    st.markdown(f"**Last Updated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | **Total Records:** {len(df)}")

if __name__ == "__main__":
    main()
