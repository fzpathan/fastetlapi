import psutil
import time
from datetime import datetime
import os
import signal
import sys

class CPUMonitor:
    def __init__(self, log_file="cpu_usage.log", interval=30):
        """
        Initialize CPU Monitor
        
        Args:
            log_file: Path to the log file
            interval: Monitoring interval in seconds (default: 30)
        """
        self.log_file = log_file
        self.interval = interval
        self.running = True
        
    def signal_handler(self, sig, frame):
        """Handle graceful shutdown on SIGINT (Ctrl+C)"""
        print("\n[INFO] Stopping CPU monitoring...")
        self.running = False
        sys.exit(0)
    
    def get_cpu_metrics(self):
        """Collect CPU metrics"""
        # Overall CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # Per-core CPU usage
        cpu_per_core = psutil.cpu_percent(interval=1, percpu=True)
        
        # CPU frequency
        cpu_freq = psutil.cpu_freq()
        
        # CPU count
        cpu_count = psutil.cpu_count(logical=True)
        physical_cores = psutil.cpu_count(logical=False)
        
        # Load average (Unix-like systems)
        try:
            load_avg = os.getloadavg()
        except AttributeError:
            load_avg = None  # Not available on Windows
        
        return {
            'timestamp': datetime.now().isoformat(),
            'cpu_percent': cpu_percent,
            'cpu_per_core': cpu_per_core,
            'cpu_freq_current': cpu_freq.current if cpu_freq else None,
            'cpu_freq_min': cpu_freq.min if cpu_freq else None,
            'cpu_freq_max': cpu_freq.max if cpu_freq else None,
            'cpu_count': cpu_count,
            'physical_cores': physical_cores,
            'load_avg_1min': load_avg[0] if load_avg else None,
            'load_avg_5min': load_avg[1] if load_avg else None,
            'load_avg_15min': load_avg[2] if load_avg else None
        }
    
    def get_memory_metrics(self):
        """Collect memory metrics"""
        # Virtual memory (RAM)
        mem = psutil.virtual_memory()
        
        # Swap memory
        swap = psutil.swap_memory()
        
        return {
            'mem_total': mem.total,
            'mem_available': mem.available,
            'mem_used': mem.used,
            'mem_percent': mem.percent,
            'mem_free': mem.free,
            'swap_total': swap.total,
            'swap_used': swap.used,
            'swap_percent': swap.percent
        }
    
    def format_bytes(self, bytes_value):
        """Convert bytes to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if bytes_value < 1024.0:
                return f"{bytes_value:.2f}{unit}"
            bytes_value /= 1024.0
        return f"{bytes_value:.2f}PB"
    
    def format_log_entry(self, cpu_metrics, mem_metrics):
        """Format metrics into a log entry"""
        log_entry = f"{cpu_metrics['timestamp']} | "
        log_entry += f"CPU: {cpu_metrics['cpu_percent']:.2f}% | "
        log_entry += f"Cores: {cpu_metrics['physical_cores']}P/{cpu_metrics['cpu_count']}L | "
        
        if cpu_metrics['cpu_freq_current']:
            log_entry += f"Freq: {cpu_metrics['cpu_freq_current']:.0f}MHz | "
        
        if cpu_metrics['load_avg_1min']:
            log_entry += f"Load: {cpu_metrics['load_avg_1min']:.2f}/{cpu_metrics['load_avg_5min']:.2f}/{cpu_metrics['load_avg_15min']:.2f} | "
        
        # Memory metrics
        log_entry += f"MEM: {mem_metrics['mem_percent']:.1f}% | "
        log_entry += f"Used: {self.format_bytes(mem_metrics['mem_used'])} | "
        log_entry += f"Avail: {self.format_bytes(mem_metrics['mem_available'])} | "
        log_entry += f"Total: {self.format_bytes(mem_metrics['mem_total'])} | "
        
        if mem_metrics['swap_total'] > 0:
            log_entry += f"SWAP: {mem_metrics['swap_percent']:.1f}% | "
        
        # Per-core usage (simplified)
        core_usage = ", ".join([f"{usage:.1f}%" for usage in cpu_metrics['cpu_per_core']])
        log_entry += f"Per-Core: [{core_usage}]"
        
        return log_entry
    
    def write_header(self):
        """Write header to log file"""
        with open(self.log_file, 'a') as f:
            f.write("\n" + "="*120 + "\n")
            f.write(f"CPU & Memory Monitoring Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("="*120 + "\n")
    
    def log_metrics(self, cpu_metrics, mem_metrics):
        """Write metrics to log file"""
        log_entry = self.format_log_entry(cpu_metrics, mem_metrics)
        
        with open(self.log_file, 'a') as f:
            f.write(log_entry + "\n")
        
        # Also print to console
        print(log_entry)
    
    def run(self):
        """Main monitoring loop"""
        # Set up signal handler for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        
        print(f"[INFO] Starting CPU & Memory monitoring...")
        print(f"[INFO] Logging to: {os.path.abspath(self.log_file)}")
        print(f"[INFO] Interval: {self.interval} seconds")
        print(f"[INFO] Press Ctrl+C to stop\n")
        
        # Write header
        self.write_header()
        
        try:
            while self.running:
                # Collect and log metrics
                cpu_metrics = self.get_cpu_metrics()
                mem_metrics = self.get_memory_metrics()
                self.log_metrics(cpu_metrics, mem_metrics)
                
                # Wait for next interval
                time.sleep(self.interval)
                
        except Exception as e:
            print(f"[ERROR] An error occurred: {e}")
            self.running = False

if __name__ == "__main__":
    # Configuration
    LOG_FILE = "cpu_usage.log"
    INTERVAL = 30  # seconds
    
    # Create and run monitor
    monitor = CPUMonitor(log_file=LOG_FILE, interval=INTERVAL)
    monitor.run()
